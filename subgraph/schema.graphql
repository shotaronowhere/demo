enum MarketType {
  Generic
  Futarchy
}

type Market @entity(immutable: false) {
  id: ID!
  type: MarketType!
  factory: Bytes!
  creator: Bytes!
  marketName: String!
  outcomes: [String!]!
  outcomesSupply: BigInt!
  lowerBound: BigInt!
  upperBound: BigInt!
  parentCollectionId: Bytes!
  parentOutcome: BigInt!
  parentMarket: Market
  childMarkets: [Market!]! @derivedFrom(field: "parentMarket")
  image: [Image!]! @derivedFrom(field: "market")
  wrappedTokens: [Token!]!
  " collateral token for Generic markets. It's either the MarketFactory's collateralToken or the parentMarket corresponding wrapped token "
  collateralToken: Token!
  " collateral token 1 for Futarchy markets "
  collateralToken1: Token!
  " collateral token 2 for Futarchy markets "
  collateralToken2: Token!
  conditionId: Bytes!
  ctfCondition: Condition!
  questionId: Bytes!
  templateId: BigInt!
  encodedQuestions: [String!]!
  payoutReported: Boolean!
  payoutNumerators: [BigInt!]!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  questions: [MarketQuestion!]! @derivedFrom(field: "market")
  openingTs: BigInt!
  hasAnswers: Boolean!
  " finalizeTs is equal to 33260976000 (random big number) if there is any unanswered question, otherwise it contains the finalizeTs value of the lattest question. This allows us to filter multi scalar markets using `finalizeTs > now` for markets with pending answers, and `finalizeTs < now` for markets with pending execution "
  finalizeTs: BigInt!
  questionsInArbitration: BigInt!
  index: BigInt!
  # liquidity across all pools in derived USD
  totalValueLockedUSD: BigDecimal!
  # TVL derived in USD untracked
  totalValueLockedUSDUntracked: BigDecimal!
  # volume in token units
  volume: BigDecimal!
  # volume in derived USD
  volumeUSD: BigDecimal!
  # volume in USD even on pools with less reliable USD values
  untrackedVolumeUSD: BigDecimal!
  tokens: [Token!]! @derivedFrom(field: "market")
  # pools derived from this market
  deposits0: [Deposit!]! @derivedFrom(field: "market0")
  deposits1: [Deposit!]! @derivedFrom(field: "market1")
}

type MarketsCount @entity(immutable: false) {
  id: ID!
  count: BigInt!
}

type Question @entity(immutable: false) {
  id: ID!
  index: Int!
  arbitrator: Bytes!
  opening_ts: BigInt!
  timeout: BigInt!
  finalize_ts: BigInt!
  is_pending_arbitration: Boolean!
  best_answer: Bytes!
  bond: BigInt!
  min_bond: BigInt!
  arbitration_occurred: Boolean!
  " MarketQuestion's that have this Question as the current question "
  marketQuestions: [MarketQuestion!]! @derivedFrom(field: "question")
  " MarketQuestion's that have this Question as the baseQuestion "
  baseQuestions: [MarketQuestion!]! @derivedFrom(field: "baseQuestion")
}

type Image @entity(immutable: false) {
  id: ID!
  market: Market!
  cidMarket: String!
  cidOutcomes: [String!]!
  LItem: LItem!
}

type MarketQuestion @entity(immutable: false) {
  id: ID!
  market: Market!
  " a market can have the same question multiple times, we use the index to identify each one of them "
  index: Int!
  " baseQuestion is the original question that was created when the market was created "
  baseQuestion: Question!
  " question is the latest question if the original question was reopened, otherwise it's the same as baseQuestion "
  question: Question!
}

type Condition @entity(immutable: false) {
  " Conditional token conditionId "
  id: ID!
  markets: [Market!]! @derivedFrom(field: "ctfCondition")
}

type ConditionalEvent @entity(immutable: true) {
  id: Bytes!
  market: Market!
  accountId: Bytes!
  type: String!
  amount: BigInt!
  blockNumber: BigInt!
  collateral: Bytes!
  transactionHash: Bytes!
}

type CurateMetadata @entity(immutable: false) {
  "The registry address"
  id: Bytes!
  "The current registration meta evidence URI"
  registrationMetaEvidenceURI: String!
  "The current removal meta evidence URI"
  clearingMetaEvidenceURI: String!
  "The number of MetaEvidence event logs emitted."
  metaEvidenceCount: BigInt!
}

type ArbitratorMetadata @entity(immutable: false) {
  "The arbitrator address"
  id: Bytes!
  "The current arbitrator meta evidence URI"
  registrationMetaEvidenceURI: String!
}

type Factory @entity(immutable: false) {
  # factory address
  id: ID!
  # amount of pools created
  poolCount: BigInt!
  # amoutn of transactions all time
  txCount: BigInt!

  # total volume all time in derived USD
  totalVolumeUSD: BigDecimal!
  # total volume all time in derived Matic
  totalVolumeMatic: BigDecimal!
  # total swap fees all time in USD
  totalFeesUSD: BigDecimal!

  # total swap fees all time in USD
  totalFeesMatic: BigDecimal!
  # all volume even through less reliable USD values
  untrackedVolumeUSD: BigDecimal!
  # TVL derived in USD
  totalValueLockedUSD: BigDecimal!
  #
  defaultCommunityFee: BigInt!
  # TVL derived in Matic
  totalValueLockedMatic: BigDecimal!
  # TVL derived in USD untracked
  totalValueLockedUSDUntracked: BigDecimal!
  # TVL derived in Matic untracked
  totalValueLockedMaticUntracked: BigDecimal!
  # current owner of the factory
  owner: ID!
}

type Token @entity(immutable: false) {
  # token address
  id: ID!
  # token symbol
  symbol: String!
  # token name
  name: String!
  # token decimals
  decimals: BigInt!
  # token total supply
  totalSupply: BigInt!
  # volume in token units
  volume: BigDecimal!
  # volume in derived USD
  volumeUSD: BigDecimal!
  # volume in USD even on pools with less reliable USD values
  untrackedVolumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # transactions across all pools that include this token
  txCount: BigInt!
  # number of pools containing this token
  poolCount: BigInt!
  # liquidity across all pools in token units
  totalValueLocked: BigDecimal!
  # liquidity across all pools in derived USD
  totalValueLockedUSD: BigDecimal!
  # TVL derived in USD untracked
  totalValueLockedUSDUntracked: BigDecimal!
  # derived price in Matic
  derivedMatic: BigDecimal!
  # pools token is in that are white listed for USD pricing
  whitelistPools: [Pool!]!
  # derived fields
  tokenDayData: [TokenDayData!]! @derivedFrom(field: "token")
  # seer token
  isSeer: Boolean!
  # pools derived from this token
  pools0: [Pool!]! @derivedFrom(field: "token0")
  # pools derived from this token
  pools1: [Pool!]! @derivedFrom(field: "token1")
  # collateral pool for the token
  poolCollateral: Pool
  # market derived from this token
  market: Market
}


type Pool @entity(immutable: false) {
  # pool address
  id: ID!
  # creation
  createdAtTimestamp: BigInt!
  # block pool was created at
  createdAtBlockNumber: BigInt!
  # token0
  token0: Token!
  # token1
  token1: Token!
  # fee amount
  fee: BigInt!
  communityFee0: BigInt!
  communityFee1: BigInt!
  # in range liquidity
  liquidity: BigInt!
  # current price tracker
  sqrtPrice: BigInt!
  # tracker for global fee growth
  feeGrowthGlobal0X128: BigInt!
  # tracker for global fee growth
  feeGrowthGlobal1X128: BigInt!
  # token0 per token1
  token0Price: BigDecimal!
  # token1 per token0
  token1Price: BigDecimal!
  #
  market0: Market
  market1: Market
  # current tick
  tick: BigInt!
  # current observation index
  observationIndex: BigInt!
  # all time token0 swapped
  volumeToken0: BigDecimal!
  # all time token1 swapped
  volumeToken1: BigDecimal!
  # all time USD swapped
  volumeUSD: BigDecimal!
  # all time USD swapped, unfiltered for unreliable USD pools
  untrackedVolumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # tick spacing
  tickSpacing: BigInt!
  #
  untrackedFeesUSD: BigDecimal!
  # all time number of transactions
  txCount: BigInt!
  # all time fees collected token0
  collectedFeesToken0: BigDecimal!
  # all time fees collected token1
  collectedFeesToken1: BigDecimal!
  # all time fees collected derived USD
  collectedFeesUSD: BigDecimal!
  # total token 0 across all ticks
  totalValueLockedToken0: BigDecimal!
  # total token 1 across all ticks
  totalValueLockedToken1: BigDecimal!
  feesToken0: BigDecimal!
  feesToken1: BigDecimal!
  # tvl derived Matic
  totalValueLockedMatic: BigDecimal!
  # tvl USD
  totalValueLockedUSD: BigDecimal!
  # TVL derived in USD untracked
  totalValueLockedUSDUntracked: BigDecimal!
  # Fields used to help derived relationship
  liquidityProviderCount: BigInt! # used to detect new exchanges
  # --- ADDED FOR ETERNAL FARMING ---
  eternalFarm: EternalFarming @derivedFrom(field: "pool")
  # --- END ADDED FOR ETERNAL FARMING ---

  # hourly snapshots of pool data
  poolHourData: [PoolHourData!]! @derivedFrom(field: "pool")
  # daily snapshots of pool data
  poolDayData: [PoolDayData!]! @derivedFrom(field: "pool")
  # derived fields
  mints: [Mint!]! @derivedFrom(field: "pool")
  burns: [Burn!]! @derivedFrom(field: "pool")
  swaps: [Swap!]! @derivedFrom(field: "pool")
  collects: [Collect!]! @derivedFrom(field: "pool")
  ticks: [Tick!]! @derivedFrom(field: "pool")
}

type Tick @entity(immutable: false) {
  # format: <pool address>#<tick index>
  id: ID!
  # pool address
  poolAddress: String
  # tick index
  tickIdx: BigInt!
  # pointer to pool
  pool: Pool!
  # total liquidity pool has as tick lower or upper
  liquidityGross: BigInt!
  # how much liquidity changes when tick crossed
  liquidityNet: BigInt!
  # calculated price of token0 of tick within this pool - constant
  price0: BigDecimal!
  # calculated price of token1 of tick within this pool - constant
  price1: BigDecimal!
  # lifetime volume of token0 with this tick in range
  volumeToken0: BigDecimal!
  # lifetime volume of token1 with this tick in range
  volumeToken1: BigDecimal!
  # lifetime volume in derived USD with this tick in range
  volumeUSD: BigDecimal!
  # lifetime volume in untracked USD with this tick in range
  untrackedVolumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # all time collected fees in token0
  collectedFeesToken0: BigDecimal!
  # all time collected fees in token1
  collectedFeesToken1: BigDecimal!
  # all time collected fees in USD
  collectedFeesUSD: BigDecimal!
  # created time
  createdAtTimestamp: BigInt!
  # created block
  createdAtBlockNumber: BigInt!
  # Fields used to help derived relationship
  liquidityProviderCount: BigInt! # used to detect new exchanges
  # derived fields
  # swaps: [Swap!]! @derivedFrom(field: "tick")
  # vars needed for fee computation
  feeGrowthOutside0X128: BigInt!
  feeGrowthOutside1X128: BigInt!
}

type PoolPosition @entity(immutable: false) {
  id: ID!
  pool: Pool!
  lowerTick: Tick!
  upperTick: Tick!
  owner: Bytes!
  liquidity: BigInt!
}

type Position @entity(immutable: false) {
  # Positions created through NonfungiblePositionManager
  # NFT token id
  id: ID!
  # owner of the NFT
  owner: Bytes!
  # pool position is within
  pool: Pool!
  # allow indexing by tokens
  token0: Token!
  # allow indexing by tokens
  token1: Token!
  # lower tick of the position
  tickLower: Tick!
  # upper tick of the position
  tickUpper: Tick!
  # total position liquidity
  liquidity: BigInt!
  # amount of token 0 ever deposited to position
  depositedToken0: BigDecimal!
  # amount of token 1 ever deposited to position
  depositedToken1: BigDecimal!
  # amount of token 0 ever withdrawn from position (without fees)
  withdrawnToken0: BigDecimal!
  # amount of token 1 ever withdrawn from position (without fees)
  withdrawnToken1: BigDecimal!
  # all time collected token0 (withdrawnToken0 + collectedFeesToken0)
  collectedToken0: BigDecimal!
  # all time collected token1 (withdrawnToken1 + collectedFeesToken1)
  collectedToken1: BigDecimal!
  # all time collected fees in token0
  collectedFeesToken0: BigDecimal!
  # all time collected fees in token1
  collectedFeesToken1: BigDecimal!
  # tx in which the position was initialized
  transaction: Transaction!
  # vars needed for fee computation
  feeGrowthInside0LastX128: BigInt!
  feeGrowthInside1LastX128: BigInt!

  token0Tvl : BigDecimal
  token1Tvl : BigDecimal 
}

type PositionSnapshot @entity(immutable: true) {
  # <NFT token id>#<block number>
  id: ID!
  # owner of the NFT
  owner: Bytes!
  # pool the position is within
  pool: Pool!
  # position of which the snap was taken of
  position: Position!
  # block in which the snap was created
  blockNumber: BigInt!
  # timestamp of block in which the snap was created
  timestamp: BigInt!
  # total position liquidity
  liquidity: BigInt!
  # amount of token 0 ever deposited to position
  depositedToken0: BigDecimal!
  # amount of token 1 ever deposited to position
  depositedToken1: BigDecimal!
  # amount of token 0 ever withdrawn from position (without fees)
  withdrawnToken0: BigDecimal!
  # amount of token 1 ever withdrawn from position (without fees)
  withdrawnToken1: BigDecimal!
  # all time collected fees in token0
  collectedFeesToken0: BigDecimal!
  # all time collected fees in token1
  collectedFeesToken1: BigDecimal!
  # tx in which the snapshot was initialized
  transaction: Transaction!
  # internal vars needed for fee computation
  feeGrowthInside0LastX128: BigInt!
  feeGrowthInside1LastX128: BigInt!
}
type Transaction @entity(immutable: true) {
  # txn hash
  id: ID!
  # block txn was included in
  blockNumber: BigInt!
  # timestamp txn was confirmed
  timestamp: BigInt!
  # gas used during txn execution
  gasLimit: BigInt!
  gasPrice: BigInt!
  # derived values
  mints: [Mint!]! @derivedFrom(field: "transaction")
  burns: [Burn!]! @derivedFrom(field: "transaction")
  swaps: [Swap!]! @derivedFrom(field: "transaction")
  flashed: [Flash!]! @derivedFrom(field: "transaction")
  collects: [Collect!]! @derivedFrom(field: "transaction")
}

type Mint @entity(immutable: true) {
  # transaction hash + "#" + index in mints Transaction array
  id: ID!
  # which txn the mint was included in
  transaction: Transaction!
  # time of txn
  timestamp: BigInt!
  # pool position is within
  pool: Pool!
  # allow indexing by tokens
  token0: Token!
  # allow indexing by tokens
  token1: Token!
  # owner of position where liquidity minted to
  owner: Bytes!
  # the address that minted the liquidity
  sender: Bytes
  # txn origin
  origin: Bytes! # the EOA that initiated the txn
  # amount of liquidity minted
  amount: BigInt!
  # amount of token 0 minted
  amount0: BigDecimal!
  # amount of token 1 minted
  amount1: BigDecimal!
  # derived amount based on available prices of tokens
  amountUSD: BigDecimal
  # lower tick of the position
  tickLower: BigInt!
  # upper tick of the position
  tickUpper: BigInt!
  # order within the txn
  logIndex: BigInt
}

type Burn @entity(immutable: true) {
  # transaction hash + "#" + index in mints Transaction array
  id: ID!
  # txn burn was included in
  transaction: Transaction!
  # pool position is within
  pool: Pool!
  # allow indexing by tokens
  token0: Token!
  # allow indexing by tokens
  token1: Token!
  # need this to pull recent txns for specific token or pool
  timestamp: BigInt!
  # owner of position where liquidity was burned
  owner: Bytes
  # txn origin
  origin: Bytes! # the EOA that initiated the txn
  # amouny of liquidity burned
  amount: BigInt!
  # amount of token 0 burned
  amount0: BigDecimal!
  # amount of token 1 burned
  amount1: BigDecimal!
  # derived amount based on available prices of tokens
  amountUSD: BigDecimal
  # lower tick of position
  tickLower: BigInt!
  # upper tick of position
  tickUpper: BigInt!
  # position within the transactions
  logIndex: BigInt
}

type Swap @entity(immutable: true) {
  # transaction hash + "#" + index in swaps Transaction array
  id: ID!
  # pointer to transaction
  transaction: Transaction!
  # timestamp of transaction
  timestamp: BigInt!
  # pool swap occured within
  pool: Pool!
  # allow indexing by tokens
  token0: Token!
  # allow indexing by tokens
  token1: Token!
  # sender of the swap
  sender: Bytes!
  # recipient of the swap
  recipient: Bytes!
  # liquidity after swap
  liquidity: BigInt!
  # txn origin
  origin: Bytes! # the EOA that initiated the txn
  # delta of token0 swapped
  amount0: BigDecimal!
  # delta of token1 swapped
  amount1: BigDecimal!
  # derived info
  amountUSD: BigDecimal!
  # The sqrt(price) of the pool after the swap, as a Q64.96
  price: BigInt!
  # the tick after the swap
  tick: BigInt!
  # index within the txn
  logIndex: BigInt
}

type Collect @entity(immutable: true) {
  # transaction hash + "#" + index in collect Transaction array
  id: ID!
  # pointer to txn
  transaction: Transaction!
  # timestamp of event
  timestamp: BigInt!
  # pool collect occured within
  pool: Pool!
  # owner of position collect was performed on
  owner: Bytes
  # amount of token0 collected
  amount0: BigDecimal!
  # amount of token1 collected
  amount1: BigDecimal!
  # derived amount based on available prices of tokens
  amountUSD: BigDecimal
  # lower tick of position
  tickLower: BigInt!
  # uppper tick of position
  tickUpper: BigInt!
  # index within the txn
  logIndex: BigInt
}

type Flash @entity(immutable: true) {
  # transaction hash + "-" + index in collect Transaction array
  id: ID!
  # pointer to txn
  transaction: Transaction!
  # timestamp of event
  timestamp: BigInt!
  # pool collect occured within
  pool: Pool!
  # sender of the flash
  sender: Bytes!
  # recipient of the flash
  recipient: Bytes!
  # amount of token0 flashed
  amount0: BigDecimal!
  # amount of token1 flashed
  amount1: BigDecimal!
  # derived amount based on available prices of tokens
  amountUSD: BigDecimal!
  # amount token0 paid for flash
  amount0Paid: BigDecimal!
  # amount token1 paid for flash
  amount1Paid: BigDecimal!
  # index within the txn
  logIndex: BigInt
}

# Data accumulated and condensed into day stats for all of Algebra
type AlgebraDayData @entity(immutable: false) {
  # timestamp rounded to current day by dividing by 86400
  id: ID!
  # timestamp rounded to current day by dividing by 86400
  date: Int!
  # total daily volume in Algebra derived in terms of Matic
  volumeMatic: BigDecimal!
  # total daily volume in Algebra derived in terms of USD
  volumeUSD: BigDecimal!
  # total daily volume in Algebra derived in terms of USD untracked
  volumeUSDUntracked: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # number of daily transactions
  txCount: BigInt!
  # tvl in terms of USD
  tvlUSD: BigDecimal!
}

# Data accumulated and condensed into day stats for each pool
type PoolDayData @entity(immutable: false) {
  # timestamp rounded to current day by dividing by 86400
  id: ID!
  # timestamp rounded to current day by dividing by 86400
  date: Int!
  # pointer to pool
  pool: Pool!
  # in range liquidity at end of period
  liquidity: BigInt!
  # current price tracker at end of period
  sqrtPrice: BigInt!
  #
  untrackedVolumeUSD: BigDecimal!
  # price of token0 - derived from sqrtPrice
  token0Price: BigDecimal!
  # price of token1 - derived from sqrtPrice
  token1Price: BigDecimal!
  # current tick at end of period
  tick: BigInt
  # tracker for global fee growth
  feeGrowthGlobal0X128: BigInt!
  # tracker for global fee growth
  feeGrowthGlobal1X128: BigInt!
  # tvl derived in USD at end of period
  tvlUSD: BigDecimal!
  feesToken0: BigDecimal!
  feesToken1: BigDecimal!
  # volume in token0
  volumeToken0: BigDecimal!
  # volume in token1
  volumeToken1: BigDecimal!
  # volume in USD
  volumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # numebr of transactions during period
  txCount: BigInt!
  # opening price of token0
  open: BigDecimal!
  # high price of token0
  high: BigDecimal!
  # low price of token0
  low: BigDecimal!
  # close price of token0
  close: BigDecimal!
}

type PoolFeeData @entity(immutable: false) {
  id: ID!

  pool: String

  timestamp: BigInt!

  fee: BigInt!

}

# hourly stats tracker for pool
type PoolHourData @entity(immutable: false) {
  # format: <pool address>-<timestamp>
  id: ID!
  # unix timestamp for start of hour
  periodStartUnix: Int!
  # pointer to pool
  pool: Pool!
  # in range liquidity at end of period
  liquidity: BigInt!
  # current price tracker at end of period
  sqrtPrice: BigInt!
  # price of token0 - derived from sqrtPrice
  token0Price: BigDecimal!
  # price of token1 - derived from sqrtPrice
  token1Price: BigDecimal!
  # current tick at end of period
  tick: BigInt
  # tracker for global fee growth
  feeGrowthGlobal0X128: BigInt!
  # tracker for global fee growth
  feeGrowthGlobal1X128: BigInt!
  # tvl derived in USD at end of period
  tvlUSD: BigDecimal!
  # volume in token0
  volumeToken0: BigDecimal!
  # volume in token1
  volumeToken1: BigDecimal!
  # volume in USD
  volumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # numebr of transactions during period
  untrackedVolumeUSD: BigDecimal!
  txCount: BigInt!
  # opening price of token0
  open: BigDecimal!
  # high price of token0
  high: BigDecimal!
  # low price of token0
  low: BigDecimal!
  # close price of token0
  close: BigDecimal!
}

type TickHourData @entity(immutable: false) {
  # format: <pool address>-<tick index>-<timestamp>
  id: ID!
  # unix timestamp for start of hour
  periodStartUnix: Int!
  # pointer to pool
  pool: Pool!
  # pointer to tick
  tick: Tick!
  # total liquidity pool has as tick lower or upper at end of period
  liquidityGross: BigInt!
  # how much liquidity changes when tick crossed at end of period
  liquidityNet: BigInt!
  # hourly volume of token0 with this tick in range
  volumeToken0: BigDecimal!
  # hourly volume of token1 with this tick in range
  volumeToken1: BigDecimal!
  # hourly volume in derived USD with this tick in range
  volumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
}

# Data accumulated and condensed into day stats for each exchange
# Note: this entity gets saved only if there is a change during the day
type TickDayData @entity(immutable: false) {
  # format: <pool address>-<tick index>-<timestamp>
  id: ID!
  # timestamp rounded to current day by dividing by 86400
  date: Int!
  # pointer to pool
  pool: Pool!
  # pointer to tick
  tick: Tick!
  # total liquidity pool has as tick lower or upper at end of period
  liquidityGross: BigInt!
  # how much liquidity changes when tick crossed at end of period
  liquidityNet: BigInt!
  # hourly volume of token0 with this tick in range
  volumeToken0: BigDecimal!
  # hourly volume of token1 with this tick in range
  volumeToken1: BigDecimal!
  # hourly volume in derived USD with this tick in range
  volumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # vars needed for fee computation
  feeGrowthOutside0X128: BigInt!
  feeGrowthOutside1X128: BigInt!
}

type TokenDayData @entity(immutable: false) {
  # token address concatendated with date
  id: ID!
  # timestamp rounded to current day by dividing by 86400
  date: Int!
  # pointer to token
  token: Token!
  # volume in token units
  volume: BigDecimal!
  # volume in derived USD
  volumeUSD: BigDecimal!
  # volume in USD even on pools with less reliable USD values
  untrackedVolumeUSD: BigDecimal!
  # liquidity across all pools in token units
  totalValueLocked: BigDecimal!
  # liquidity across all pools in derived USD
  totalValueLockedUSD: BigDecimal!
  # price at end of period in USD
  priceUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # opening price USD
  open: BigDecimal!
  # high price USD
  high: BigDecimal!
  # low price USD
  low: BigDecimal!
  # close price USD
  close: BigDecimal!
}

type TokenHourData @entity(immutable: false) {
  # token address concatendated with date
  id: ID!
  # unix timestamp for start of hour
  periodStartUnix: Int!
  # pointer to token
  token: Token!
  # volume in token units
  volume: BigDecimal!
  # volume in derived USD
  volumeUSD: BigDecimal!
  # volume in USD even on pools with less reliable USD values
  untrackedVolumeUSD: BigDecimal!
  # liquidity across all pools in token units
  totalValueLocked: BigDecimal!
  # liquidity across all pools in derived USD
  totalValueLockedUSD: BigDecimal!
  # price at end of period in USD
  priceUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # opening price USD
  open: BigDecimal!
  # high price USD
  high: BigDecimal!
  # low price USD
  low: BigDecimal!
  # close price USD
  close: BigDecimal!
}

type FeeHourData @entity(immutable: false) {
  #
  id: ID!
  #
  pool: String!
  #
  fee: BigInt!
  #
  changesCount: BigInt!
  #
  timestamp: BigInt!
  #
  minFee: BigInt!
  #
  maxFee: BigInt!
  #
  startFee: BigInt!
  #
  endFee: BigInt! 
}


type LimitFarming @entity(immutable: false) {
  id: ID!
  createdAtTimestamp: BigInt!
  rewardToken: Bytes!
  bonusRewardToken: Bytes!
  pool: Bytes!
  startTime: BigInt!
  endTime: BigInt!
  reward: BigInt!
  bonusReward: BigInt!
  isDetached: Boolean
  minRangeLength: BigInt!
  tokenAmountForTier1: BigInt!
  tokenAmountForTier2: BigInt!
  tokenAmountForTier3: BigInt!
  tier1Multiplier: BigInt!
  tier2Multiplier: BigInt!
  tier3Multiplier: BigInt!
  multiplierToken: Bytes!
  enterStartTime: BigInt!
}

type EternalFarming @entity(immutable: false) {
  id: ID!
  rewardToken: Bytes!
  bonusRewardToken: Bytes!
  virtualPool: Bytes!
  pool: Pool!
  startTime: BigInt!
  endTime: BigInt!
  endTimeImplied: BigInt!
  timestampActiveLiquidity: BigInt!
  reward: BigInt!
  rewardReserve: BigInt!
  bonusReward: BigInt!
  rewardRate: BigInt!
  bonusRewardRate: BigInt!
  isDetached: Boolean
  minRangeLength: BigInt!
  tokenAmountForTier1: BigInt!
  tokenAmountForTier2: BigInt!
  tokenAmountForTier3: BigInt!
  tier1Multiplier: BigInt!
  tier2Multiplier: BigInt!
  tier3Multiplier: BigInt!
  multiplierToken: Bytes!
  # --- ADDED FOR DERIVED DEPOSITS ---
  deposits: [Deposit!]! @derivedFrom(field: "eternalFarming")
  # --- END ADDED FOR DERIVED DEPOSITS ---
  # --- ADDED totalLiquidity and totalActiveLiquidity as discussed ---
  totalLiquidity: BigInt! # Total liquidity staked in this farm
  totalActiveLiquidity: BigInt! # Total liquidity currently eligible for rewards
  # --- END ---
  totalAmountUSDEstimated: BigDecimal!
}

type Deposit @entity(immutable: false) {
  id: ID! # This is the NFT Token ID from NonfungiblePositionManager
  mint: Mint!
  mintUSD: BigDecimal!
  L2tokenId: BigInt!
  owner: Bytes! # Current owner of the NFT
  onFarmingCenter: Boolean! # True if the NFT is staked in the FarmingCenter
  pool: Pool! # Pool the underlying position is in (set from Position data)
  market0: Market
  market1: Market
  limitFarming: LimitFarming # Link to LimitFarming if staked
  eternalFarming: EternalFarming # Link to EternalFarming if staked
  enteredInEternalFarming: BigInt 
  liquidity: BigInt! # Liquidity of the position (can be updated by Increase/DecreaseLiquidity on NPM)
  # For eternal farming, this liquidity value is snapshotted at the moment of staking into the farm (FarmEntered event)
  # and used for that farm's accounting, to avoid discrepancies if underlying NFT liquidity changes while staked.
  
  # Fields derived or copied from the underlying Position for convenience in farm eligibility checks
  rangeLength: BigInt! # (tickUpper - tickLower) for the position
  
  tokensLockedLimit: BigInt!
  tokensLockedEternal: BigInt!
  tierLimit: BigInt!
  tierEternal: BigInt! 
}

type Reward @entity(immutable: false) {
  id: ID!
  rewardAddress: Bytes!
  amount: BigInt!
  owner: Bytes!
}

type MarketDayData @entity(immutable: false) {
  id: ID!
  date: Int!
  market: Market!
  # volume in token units
  volume: BigDecimal!
  # volume in derived USD
  volumeUSD: BigDecimal!
  # volume in USD even on pools with less reliable USD values
  untrackedVolumeUSD: BigDecimal!
  # liquidity across all pools in derived USD
  totalValueLockedUSD: BigDecimal!
  # TVL derived in USD untracked
  totalValueLockedUSDUntracked: BigDecimal!
}

type MarketHourData @entity(immutable: false) {
  id: ID!
  periodStartUnix: Int!
  market: Market!
  # volume in token units
  volume: BigDecimal!
  # volume in derived USD
  volumeUSD: BigDecimal!
  # volume in USD even on pools with less reliable USD values
  untrackedVolumeUSD: BigDecimal!
  # liquidity across all pools in derived USD
  totalValueLockedUSD: BigDecimal!
  # TVL derived in USD untracked
  totalValueLockedUSDUntracked: BigDecimal!
}

enum Status {
  "The item is not registered on the TCR and there are no pending requests."
  Absent
  "The item is registered and there are no pending requests."
  Registered
  "The item is not registered on the TCR, but there is a pending registration request."
  RegistrationRequested
  "The item is registered on the TCR, but there is a pending removal request. These are sometimes also called removal requests."
  ClearingRequested
}

enum Ruling {
  "The arbitrator did not rule or refused to rule."
  None
  "The arbitrator ruled in favor of the requester."
  Accept
  "The arbitrator in favor of the challenger."
  Reject
}

type Arbitrator @entity(immutable: false) {
  "The address of the arbitrator"
  id: ID!
}

type LArbitrator @entity(immutable: false) {
  "The address of the arbitrator"
  id: ID!
}

type EvidenceGroup @entity(immutable: false) {
  "evidenceGroupId@tcrAddress"
  id: ID!
  "Evidences posted to this evidenceGroupId"
  evidences: [Evidence!]! @derivedFrom(field: "evidenceGroup")
  "Number of evidences posted in this group"
  numberOfEvidence: BigInt!
}

type Evidence @entity(immutable: true) {
  "evidenceGroupId@tcrAddress-number"
  id: ID!
  "The arbitrator's address."
  arbitrator: Bytes!
  "The evidence group"
  evidenceGroup: EvidenceGroup!
  "The address of the party that sent this piece of evidence."
  party: Bytes!
  "The URI of the evidence file."
  URI: String!
  "This is the <number>th evidence submitted (starting at 0) for <request>."
  number: BigInt!
  "When was this evidence posted"
  timestamp: BigInt!
  "Tx hash of the evidence submission"
  txHash: Bytes!
  metadata: EvidenceMetadata
}

type EvidenceMetadata @entity(immutable: true) {
  id: ID!
  "Name of the evidence"
  name: String
  "Title of the evidence"
  title: String
  "Description of the evidence"
  description: String
  "URI of the attached file"
  fileURI: String
  "File extension of the attached file"
  fileTypeExtension: String
}

type Registry @entity(immutable: false) {
  "The registry address"
  id: ID!
  "The current registration meta evidence"
  registrationMetaEvidence: MetaEvidence!
  "The current removal meta evidence"
  clearingMetaEvidence: MetaEvidence!
  "The number of MetaEvidence event logs emitted."
  metaEvidenceCount: BigInt!
  "The items submitted to this list"
  items: [Item!]! @derivedFrom(field: "registry")
  "The requests submitted to this list"
  requests: [Request!]! @derivedFrom(field: "registry")
  "The number of items submitted to the list."
  numberOfItems: BigInt!
  "Connected TCR. Can be the 0 address. In practice, will never be null."
  connectedTCR: Bytes
}

type LRegistry @entity(immutable: false) {
  "The registry address"
  id: ID!
  "The current registration meta evidence"
  registrationMetaEvidence: MetaEvidence!
  "The current removal meta evidence"
  clearingMetaEvidence: MetaEvidence!
  "The number of MetaEvidence event logs emitted."
  metaEvidenceCount: BigInt!
  "The items submitted to this list"
  items: [LItem!]! @derivedFrom(field: "registry")
  "The requests submitted to this list"
  requests: [LRequest!]! @derivedFrom(field: "registry")
  "The total number of items in absent state."
  numberOfAbsent: BigInt!
  "The total number of items in registered state."
  numberOfRegistered: BigInt!
  "The total number of items in the registration requested state."
  numberOfRegistrationRequested: BigInt!
  numberOfClearingRequested: BigInt!
  "The total number of items in the challenged registration state."
  numberOfChallengedRegistrations: BigInt!
  "The total number of items in the challenged removal state."
  numberOfChallengedClearing: BigInt!
  "Connected TCR. Can be the 0 address. In practice, will never be null."
  connectedTCR: Bytes
  metadata: LRegistryMetadata
}

type LRegistryMetadata @entity(immutable: true) {
 id: ID!
 title: String
 description: String
 itemName: String
 itemNamePlural: String
 isConnectedTCR: Boolean
 requireRemovalEvidence: Boolean
 isTCRofTcrs: Boolean
 parentTCRAddress: String
 relTcrDisabled: Boolean
 registry: LRegistry @derivedFrom(field: "metadata")
}


type MetaEvidence @entity(immutable: true) {
  "The meta evidence ID."
  id: ID!
  "The URI of the meta evidence file."
  URI: String!
}

type LItem @entity(immutable: false) {
  "The id of the item in the subgraph entity. Format: <itemID>@<listaddress_lowercase>"
  id: ID!
  "The ID of the item in the registry. Also the keccak256 hash of the data."
  itemID: Bytes!
  "The data describing the item."
  data: String!
  "The current status of the item."
  status: Status!
  "List of status change requests made for the item in the form requests[requestID]."
  requests: [LRequest!]! @derivedFrom(field: "item")
  "The total number of requests for this item."
  numberOfRequests: BigInt!
  "The registry where this item was submitted."
  registry: LRegistry!
  "The address of the registry this item was submitted. Redundant with registry field to allow use in conditionals."
  registryAddress: Bytes!
  "Time when the latest request was made."
  latestRequestSubmissionTime: BigInt!
  "The time the latest request was resolved."
  latestRequestResolutionTime: BigInt!
  "Whether the item is currently disputed."
  disputed: Boolean!
  "The account that made the latest request to the item."
  latestRequester: Bytes!
  "The account that challenged the latest request, if any."
  latestChallenger: Bytes!
  metadata: LItemMetadata
}

type LItemMetadata @entity(immutable: true) {
  "ipfs cid - Litem ID"
  id: ID!
  "The parsed data describing the item."
  props: [ItemProp!]! @derivedFrom(field: "item")
  "First indexable value of the json file."
  key0: String
  "Second indexable value of the json file."
  key1: String
  "Third indexable value of the json file."
  key2: String
  "Fourth indexable value of the json file."
  key3: String
  "Fifth indexable value of the json file."
  key4: String
  "The item identifiers combined as a single string."
  keywords: String
  "The item this metadata belongs to"
  item: LItem! @derivedFrom(field: "metadata")
  metametadata: LItemMetametadata
}


type LItemMetametadata @entity(immutable: true) {
  "ipfs cid - Metadata ID"
  id: ID!
  "The parsed data describing the item."
  props: [MetaItemProp!]! @derivedFrom(field: "metaitem")
  "First indexable value of the json file."
  key0: String
  "Second indexable value of the json file."
  key1: String
  "Third indexable value of the json file."
  key2: String
  "Fourth indexable value of the json file."
  key3: String
  "Fifth indexable value of the json file."
  key4: String
  "The item identifiers combined as a single string."
  keywords: String
  "The item metadata this metametadata belongs to"
  metadata: LItemMetadata! @derivedFrom(field: "metametadata")
}

type _Schema_
  @fulltext(
    name: "itemSearch"
    language: en
    algorithm: rank
    include: [{ entity: "LItemMetadata", fields: [{ name: "keywords" }] }]
  )
  @fulltext(
    name: "registrySearch"
    language: en
    algorithm: rank
    include: [{ entity: "LRegistryMetadata", fields: [{ name: "title" }, { name: "description" }, { name: "itemName" }] }]
  )

type ItemProp @entity(immutable: true) {
  id: ID!
  type: String!
  label: String!
  description: String!
  isIdentifier: Boolean!
  value: String
  item: LItemMetadata!
}

type MetaItemProp @entity(immutable: true) {
  id: ID!
  market: String!
  outcomes: [String!]!
  metaitem: LItemMetametadata!
}

type LRequest @entity(immutable: false) {
  "The item ID (which is the keccak256 hash of its data)."
  id: ID!
  "True if a dispute was raised."
  disputed: Boolean!
  "ID of the dispute, if any."
  disputeID: BigInt!
  "Time when the request was made. Used to track when the challenge period ends."
  submissionTime: BigInt!
  "True if the request was executed and/or any raised disputes were resolved."
  resolved: Boolean!
  "The address of the party that made a request"
  requester: Bytes!
  "The address of the party that challenged the request"
  challenger: Bytes!
  "The arbitrator trusted to solve disputes for this request."
  arbitrator: Bytes!
  "The extra data for the trusted arbitrator of this request."
  arbitratorExtraData: Bytes!
  "The deposit that would be awarded to the challenger if challenge is successful"
  deposit: BigInt!
  "The outcome of the dispute, if any. Note that unsuccessful appeal fundings can invert the arbitrator ruling (so this may differ from the ruling given by the arbitrator)."
  disputeOutcome: Ruling!
  "Tracks each round of a dispute in the form rounds[roundID]."
  rounds: [LRound!]! @derivedFrom(field: "request")
  "The evidence group for this request."
  evidenceGroup: EvidenceGroup!
  "The total number of rounds on this request."
  numberOfRounds: BigInt!
  "Whether it was requested to add or remove the item to/from the list."
  requestType: Status!
  "The URI to the meta evidence used for this request."
  metaEvidence: MetaEvidence!
  "The item this request belongs to."
  item: LItem!
  "The registry where this request was submitted."
  registry: LRegistry!
  "The address of the registry this item was submitted. Redundant with registry field to allow use in conditionals."
  registryAddress: Bytes!
  "The time the request was resolved."
  resolutionTime: BigInt!
  "Only set if the request was settled by a dispute. Used by the twitter bot"
  finalRuling: BigInt
  "The hash of the transaction that created this request."
  creationTx: Bytes!
  "The hash of the transaction that solved this request."
  resolutionTx: Bytes
}

type LRound @entity(immutable: false) {
  id: ID!
  "The total amount of appeal fees contributed to the requester in this round."
  amountPaidRequester: BigInt!
  "The total amount of appeal fees contributed to the challenger in this round."
  amountPaidChallenger: BigInt!
  "Whether the requester is fully funded."
  hasPaidRequester: Boolean!
  "Whether the challenger is fully funded."
  hasPaidChallenger: Boolean!
  "When was the last contribution for requester (hack for curate bot)"
  lastFundedRequester: BigInt!
  "When was the last contribution for challenger (hack for curate bot)"
  lastFundedChallenger: BigInt!
  "Sum of reimbursable fees and stake rewards available to the parties that made contributions to the side that ultimately wins a dispute."
  feeRewards: BigInt!
  "The request to which this round belongs."
  request: LRequest!
  "The time the appeal period starts, if in the appeal period."
  appealPeriodStart: BigInt!
  "The time the appeal period ends, if in the appeal period."
  appealPeriodEnd: BigInt!
  "The time the round received the ruling."
  rulingTime: BigInt!
  "The ruling given by the arbitrator."
  ruling: Ruling!
  "The tx hash of the moment appealing became possible"
  txHashAppealPossible: Bytes
  "The tx hash of the moment the round was appealed"
  txHashAppealDecision: Bytes
  "The moment the round was created."
  creationTime: BigInt!
  "The contributions made to this round."
  contributions: [LContribution!]! @derivedFrom(field: "round")
  "The number of contributions made to this round"
  numberOfContributions: BigInt!
  "Whether this round was appealed."
  appealed: Boolean!
  "When this round was appealed, if it was appealed"
  appealedAt: BigInt
}

type LContribution @entity(immutable: false) {
  "The contribution ID."
  id: ID!
  "The round the contribution was made to."
  round: LRound!
  "The address that made the contribution."
  contributor: Bytes!
  "Whether there are any withdrawable contributions."
  withdrawable: Boolean!
  "To which side the contribution was made."
  side: BigInt!
}

type Round @entity(immutable: false) {
  "<itemID>-<requestID>-<roundID>"
  id: ID!
  "The total amount of appeal fees contributed to the requester in this round."
  amountPaidRequester: BigInt!
  "The total amount of appeal fees contributed to the challenger in this round."
  amountPaidChallenger: BigInt!
  "Whether the requester is fully funded."
  hasPaidRequester: Boolean!
  "Whether the challenger is fully funded."
  hasPaidChallenger: Boolean!
  "Sum of reimbursable fees and stake rewards available to the parties that made contributions to the side that ultimately wins a dispute."
  feeRewards: BigInt!
  "The request to which this round belongs."
  request: Request!
  "The time the appeal period starts, if in the appeal period."
  appealPeriodStart: BigInt!
  "The time the appeal period ends, if in the appeal period."
  appealPeriodEnd: BigInt!
  "The time the round received the ruling."
  rulingTime: BigInt!
  "The ruling given by the arbitrator."
  ruling: Ruling!
  "The tx hash of the moment appealing became possible"
  txHashAppealPossible: Bytes
  "The tx hash of the moment the round was appealed"
  txHashAppealDecision: Bytes
  "The moment the round was created."
  creationTime: BigInt!
  "Whether this round was appealed"
  appealed: Boolean!
  "When this round was appealed, if it was appealed"
  appealedAt: BigInt
}

type Item @entity(immutable: false) {
  "The id of the item in the subgraph entity. Format: <itemID>@<listaddress_lowercase>"
  id: ID!
  "The ID of the item in the registry. Also the keccak256 hash of the data."
  itemID: Bytes!
  "The data describing the item."
  data: Bytes!
  "The current status of the item."
  status: Status!
  "List of status change requests made for the item in the form requests[requestID]."
  requests: [Request!]! @derivedFrom(field: "item")
  "The total number of requests for this item."
  numberOfRequests: BigInt!
  "The registry where this item was submitted."
  registry: Registry!
  "The address of the registry this item was submitted. Redundant with registry field to allow use in conditionals."
  registryAddress: Bytes!
  "Time when the latest request was made."
  latestRequestSubmissionTime: BigInt!
  "The time the latest request was resolved."
  latestRequestResolutionTime: BigInt!
  "Whether the item is currently disputed."
  disputed: Boolean!
  "The account that made the latest request to the item."
  latestRequester: Bytes!
  "The account that challenged the latest request, if any."
  latestChallenger: Bytes!
}

type Request @entity(immutable: false) {
  "<itemID>-<requestId>"
  id: ID!
  "True if a dispute was raised."
  disputed: Boolean!
  "ID of the dispute, if any."
  disputeID: BigInt!
  "Time when the request was made. Used to track when the challenge period ends."
  submissionTime: BigInt!
  "True if the request was executed and/or any raised disputes were resolved."
  resolved: Boolean!
  "The address of the party that made a request"
  requester: Bytes!
  "The address of the party that challenged the request"
  challenger: Bytes!
  "The arbitrator trusted to solve disputes for this request."
  arbitrator: Bytes!
  "The extra data for the trusted arbitrator of this request."
  arbitratorExtraData: Bytes!
  "The deposit that would be awarded to the challenger if challenge is successful"
  deposit: BigInt!
  "The outcome of the dispute, if any. Note that unsuccessful appeal fundings can invert the arbitrator ruling (so this may differ from the ruling given by the arbitrator)."
  disputeOutcome: Ruling!
  "Tracks each round of a dispute in the form rounds[roundID]."
  rounds: [Round!]! @derivedFrom(field: "request")
  "The evidence group for this request."
  evidenceGroup: EvidenceGroup!
  "The total number of rounds on this request."
  numberOfRounds: BigInt!
  "Whether it was requested to add or remove the item to/from the list."
  requestType: Status!
  "The URI to the meta evidence used for this request."
  metaEvidence: MetaEvidence!
  "The item this request belongs to."
  item: Item!
  "The registry where this request was submitted."
  registry: Registry!
  "The address of the registry this item was submitted. Redundant with registry field to allow use in conditionals."
  registryAddress: Bytes!
  "The time the request was resolved."
  resolutionTime: BigInt!
  "Only set if the request was settled by a dispute. Used by the twitter bot"
  finalRuling: BigInt
  "The hash of the transaction that created this request."
  creationTx: Bytes!
  "The hash of the transaction that solved this request."
  resolutionTx: Bytes
}

type HasPaidAppealFee @entity(immutable: false) {
  "<itemID>-<requestID>-<roundID>-<side>"
  id: ID!

  item: Item!

  request: Request!

  round: Round!
  "Side the fund is in favor of"
  side: BigInt!
  "Timestamp of the event"
  timestamp: BigInt!
}
